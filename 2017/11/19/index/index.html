<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 进程与线程概念理解 · Hexo</title><meta name="description" content="进程与线程概念理解 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">进程与线程概念理解</h1><div class="post-info">Nov 19, 2017</div><div class="post-content"><p>&#160; &#160; &#160; &#160;线程是什么？要理解这个概念，须要先了解一下操作系统的一些相关概念。大部分操作系统(如Windows、Linux)的任务调度是采用时间片轮转的抢占式调度方式，也就是说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。任务执行的一小段时间叫做时间片，任务正在执行时的状态叫运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态等待下一个属于它的时间片的到来。这样每个任务都能得到执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发(别觉得并发有多高深，它的实现很复杂，但它的概念很简单，就是一句话：多个任务同时执行)。<br><a id="more"></a></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>&#160; &#160; &#160; &#160;一个进程，包括了代码、数据和分配给进程的资源（内存），在计算机系统里直观地说一个进程就是一个PID。操作系统保护进程空间不受外部进程干扰，即一个进程不能访问到另一个进程的内存。有时候进程间需要进行通信，这时可以使用操作系统提供进程间通信机制。通常情况下，执行一个可执行文件操作系统会为其创建一个进程以供它运行。但如果该执行文件是基于多进程设计的话，操作系统会在最初的进程上创建出多个进程出来，这些进程间执行的代码是一样，但执行结果可能是一样的，也可能是不一样的。<br>&#160; &#160; &#160; &#160;为什么需要多进程？最直观的想法是，如果操作系统支持多核的话，那么一个执行文件可以在不同的核心上跑；即使是非多核的，在一个进程在等待I/O操作时另一个进程也可以在CPU上跑，提高CPU利用率、程序的效率。<br>&#160; &#160; &#160; &#160;在Linux系统上可以通过fork()来在父进程中创建出子进程。一个进程调用fork()后，系统会先给新进程分配资源，例如存储数据和代码空间。然后把原来进程的所有值、状态都复制到新的进程里，只有少数的值与原来的进程不同，以区分不同的进程。fork()函数会返回两次，一次给父进程（返回子进程的pid或者fork失败信息），一次给子进程（返回0）。至此，两个进程分道扬镳，各自运行在系统里。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"the exit pid: %d \n"</span>, getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line"> 	atexit(print_exit); <span class="comment">// 注册该进程退出时候的回调函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"i am in the master process, the process id is : %d \n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">	pid = fork(); <span class="comment">// 创建新的进程</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   	<span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"something wrong in process fork! \n"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"i am in the child process, the child process id is : %d, the parent process id is : %d \n"</span>, getpid(), getppid());</span><br><span class="line">		count++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"child process add count. \n"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"i am in the parent process, the parent process id id : %d \n"</span>, getpid());</span><br><span class="line">		count++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"parent process add count. \n"</span>);</span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"At last, count equals to %d \n"</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码输出如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i am in the master process, the process id is : <span class="number">14690</span></span><br><span class="line">i am in the parent process, the parent process id id : <span class="number">14690</span></span><br><span class="line">parent process add count.</span><br><span class="line">i am in the child process, the child process id is : <span class="number">14691</span>, the parent process id is : <span class="number">14690</span></span><br><span class="line">child process add count.</span><br><span class="line">At last, count equals to <span class="number">1</span></span><br><span class="line">the <span class="built_in">exit</span> pid: <span class="number">14691</span></span><br><span class="line">At last, count equals to <span class="number">1</span></span><br><span class="line">the <span class="built_in">exit</span> pid: <span class="number">14690</span></span><br></pre></td></tr></table></figure></p>
<p>明显两个进程都执行了count++操作，但由于count是分别处在不同的进程里，所以实质上count在各自进程上只执行了一次。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>&#160; &#160; &#160; &#160;线程是可执行代码的可分派单元，CPU可单独执行单元。在基于线程的多任务的环境中，所有进程至少有一个线程（主线程），但是它们可以具有多个任务。这意味着单个程序可以并发执行两个或者多个任务。也就是说，线程可以把一个进程分为很多片，每一片都可以是一个独立的流程，CPU可以选择其中的流程来执行。但线程不是进程，不具有PID，且分配的资源属于它的进程，共享着进程的全局变量，也可以有自己“私有”空间。但这明显不同于多进程，进程是一个拷贝的流程，而线程只是把一条河流截成很多条小溪。它没有拷贝这些额外的开销，但是仅仅是现存的一条河流，就被多线程技术几乎无开销地转成很多条小流程，它的伟大就在于它少之又少的系统开销。<br>&#160; &#160; &#160; &#160;Linux中可以使用pthread库来创建线程，但由于pthread不是Linux内核的默认库，所以编译时需要加入pthread库一同编译。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">task1</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">task2</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usr</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">int</span> p1,p2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	usr();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> pid1, pid2;</span><br><span class="line">	<span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">	<span class="keyword">void</span> *p1, *p2;</span><br><span class="line">	<span class="keyword">int</span> ret1 = <span class="number">0</span>, ret2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	pthread_attr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line">	pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line">	pthread_create(&amp;pid1, &amp;attr, task1, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line">	pthread_create(&amp;pid2, &amp;attr, task2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	ret1 = pthread_join(pid1, &amp;p1);</span><br><span class="line">	ret2 = pthread_join(pid2, &amp;p2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"after pthread1:ret1=%d\n"</span>, ret1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"after pthread2:ret2=%d\n"</span>, ret2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"at last, count equals to %d\n"</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">task1</span><span class="params">(<span class="keyword">void</span> *arg1)</span> </span>&#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"task1 sleep 2.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"task1 begin.\n"</span>);</span><br><span class="line">	count++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"task1 thread add count.\n"</span>);</span><br><span class="line">	pthread_exit((<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">task2</span><span class="params">(<span class="keyword">void</span> *arg2)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"task2 begin\n"</span>);</span><br><span class="line">	count++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"task2 thread add count.\n"</span>);</span><br><span class="line">	pthread_exit((<span class="keyword">void</span> *)<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序输出<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">task2 begin</span><br><span class="line">task2 thread add count.</span><br><span class="line">task1 sleep <span class="number">2.</span></span><br><span class="line">task1 begin.</span><br><span class="line">task1 thread add count.</span><br><span class="line">after pthread1:ret1=<span class="number">0</span></span><br><span class="line">after pthread2:ret2=<span class="number">0</span></span><br><span class="line">at last, count equals to <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;显示task2先于task1执行，表明了这不是一个同步的程序，线程的运行是单独进行的，由内核线程调度来进行的。为了区别进程，在代码中也加入了count++操作。最后在主线程中输出count=2，即count被计数了2次，子线程被允许使用同一个进程内的共享变量，区别了进程的概念。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>线程是程序执行的最小单元，而进程是操作系统分配资源的最小单位；</li>
<li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li>
<li>进程之间相互独立，但同一个进程下的各个线程之间共享程序的内存空间（包括代码段，数据集，堆等）及一些进程级的资源（如打开文件和信号），某进程内的线程在其他进程内不可见；</li>
<li>调度和切换：线程上下文切换比进程上下文切换要快得多.  </li>
</ol>
<p>&#160; &#160; &#160; &#160;总之，线程和进程都是一种抽象的概念，线程是一种比进程更小的抽象，线程和进程都可以实现并发。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://blog.csdn.net/luoweifu/article/details/46595285" target="_blank" rel="noopener">以操作系统的角度叙说进程和线程</a></li>
<li><a href="http://blog.csdn.net/Jeffery_Gong/article/details/51329305" target="_blank" rel="noopener">多进程和多线程的概念理解</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2017/11/19/PHP多进程初探/" class="prev">上一篇</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>